# SideQuest — Status Check (5:15 PM, Feb 7)

Personal notes. Not for push.

---

## What We're Building

SideQuest is a time-fit action router. You tell it how much free time you have, where you are, and how you're getting around. It returns places that actually fit in your window — not "best rated," not "most popular," but "you can go here, spend time, get back, and not be late."

The app is the demo. The real product is the routing engine + ML scoring + our own categorization layer on top of Google's raw place data. That's what makes this a company and not a Google Maps wrapper.

Name: **SideQuest**. Previously "Sorcerer Troop."

---

## The Problem

New grads move to a new city and lose their default community. They have fragmented free time (20-90 min gaps) but high friction to figure out what to do with it. The default is scrolling. We want the default to be "go somewhere."

Nobody answers the question: "I have 40 minutes — what can I actually do right now, near me, that fits?"

---

## How We're Doing It

Three services:

```
/web     → Next.js frontend (teammate built in Cursor)
/server  → Express + TypeScript (API layer — calls Google, ML, returns results)
/ml      → Python + FastAPI (Tommy's preference scoring model)
```

**The pipeline:**
1. User opens app → picks time window, transport mode, vibe
2. Frontend sends request to Express server
3. Server hits Google Places API → gets nearby candidates
4. Server filters by distance (haversine heuristic, free) → keeps top 10
5. Server gets real travel times (Google Routes API) for those 10
6. Server calculates time-fit: travel_to + dwell + travel_back + buffer <= window
7. Server sends candidates to ML service for scoring
8. ML scores based on user preferences (this is the moat)
9. Server enforces diversity (no 5 coffee shops), returns top 5
10. Frontend renders suggestion cards

**What makes this not a wrapper:**
- Our own categorization layer on Google's places (we decide what a place "is," not Google's types)
- ML preference model that learns what kind of person you are
- Time-fit as a hard constraint (nobody else does this)
- The outcome dataset: what people actually do with X minutes at Y time

---

## The Core Product

The ML model is the business. The Express server is plumbing. The frontend is a reference client.

The ML service (`/ml`) takes candidates + user profile and returns personalized scores. Over time it learns: this person always picks coffee in morning gaps, never picks fitness, prefers <8 min walks. That preference data is what compounds.

The categorization layer is what separates us from "fetch from Google and display." We're building our own understanding of Norman places first — what each place actually is, how long people spend there, what vibe it serves. This is scoped to Norman for the hackathon so we can verify everything and build a real dataset.

---

## Where We Are Now

### Done
- **Server compiled and running** on port 3001
- **Health endpoint works** — `GET /api/health` returns OK
- **Suggest endpoint works** — tested with real Norman coords + Google API key
  - Google Places returns real places
  - Scoring engine runs (local heuristic)
  - Time-fit filtering works
  - Got back a bookstore with 0.93 score for "chill" vibe
- **Full server scaffold** — types, config, all services (vibes, fit, scoring, places, routes, weather), all routes (suggest, feedback, health)
- **Input normalization** — backend now accepts both frontend format (`"WALK"`, `vibe: "Chill"`) and backend format (`"walking"`, `vibes: ["chill"]`)
- **Frontend exists** — landing page, "I'm Free Now" flow, time/vibe/transport selectors, suggestion cards, skeleton loading states
- **Frontend points at server** — fetch URL updated to `localhost:3001`
- **Docs cleaned up** — architecture locked to 3 services, duplicate backend code deleted from /web
- **PR #2 open** on `server-scaffold` branch

### Not Done
- **ML service** — Tommy pushing soon. Need to see his `/score` contract and wire it in
- **Norman place database** — our own categorization on top of Google's data. This is priority #1 after ML
- **Frontend ↔ server tested end-to-end** — individual pieces work but haven't run both together and clicked through the UI
- **User survey / onboarding** — need rich inputs for ML model (not just vibe picker)
- **Response shape alignment** — server sends `reasonCodes`, frontend expects `reason`. Server doesn't send `bufferMinutes` or `mapsUrl` that frontend expects
- **No database** — feedback is in-memory only, fine for demo
- **No weather** — skipped intentionally, not needed
- **Routes API** — falls back to distance heuristic (works fine, saves money)

---

## What's Left To Do

### Critical (demo must work)
1. **Get ML model pushed and wired in** — see Tommy's endpoint contract, connect server scoring step to it
2. **Norman categorization layer** — take Google's places for Norman, add our own metadata (real vibe, real dwell times, our categories)
3. **Fix response shape mismatches** — align server output with what frontend components expect (`reason` vs `reasonCodes`, missing `bufferMinutes`/`mapsUrl`)
4. **End-to-end test** — run web + server together, click "Route me," see real suggestion cards
5. **Demo script** — 60-second pitch rehearsed, backup data if APIs fail

### Important (makes demo convincing)
6. **User onboarding / survey** — rich input for ML model, not just vibes
7. **Polish suggestion cards** — make sure they render cleanly with real data
8. **Loading + error states** — already built, just need to test with real latency

### Nice to have
9. Routes API for real travel times (heuristic works fine)
10. Stats / "reclaimed time" screen
11. Safety mode for night suggestions

---

## Key Decisions Made
- **Norman only** for hackathon — own the data for one area
- **No weather** — not needed for demo
- **3-service architecture** — web (frontend only) + server (API) + ml (scoring)
- **ML is the moat** — not vibes picker, not Google wrapper
- **Name is SideQuest**
